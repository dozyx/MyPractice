#### ViewConfiguration

获取 UI 相关的一些常量，如超时、尺寸、距离。



#### VelocityTracker

跟踪触摸事件的速度，用来实现 fling 或类似手势。

用法：

```java
// 获取实例
mVelocityTracker = VelocityTracker.obtain();
// 将 event 添加到 tracker 中。应该添加所有的触摸事件包括 Down、Move、Up
mVelocityTracker.addMovement(ev);
// 计算当前速度，只在需要获取速度时调用。第一个参数 1000 表示获取的速度是每秒多少像素，第二个参数表示允许的最大速度。
mVelocityTracker.computeCurrentVelocity(1000, mMaxVelocity)；
// 获取速度。下滑、右滑速度为正。
mVelocityTracker.getXVelocity()
mVelocityTracker.getYVelocity()
// 回收资源
mVelocityTracker.recycle()
```



#### Scroller

> 除了 Scroller，还有一个类似功能的 OverScroller 

用来收集制作滚动动画所需要的数据，如 fling 手势。Scroller 会跟踪随时间变化的滚动偏移量，但不会自动将这些位置信息应用到 View 中。所以，在实现平滑滚动时，开发者需要自行处理。

基本使用：

```java
public CustomView(Context context, AttributeSet attrs){
    super(context, attrs);
    mScroller = new Scroller(context);
}

@Override
public void computeScroll(){
    super.computeScroll();
    if(mScroller.computeScrollOffset()){
        ((View)getParent()).scrollTo(mScroller.getCurrX(), mScroller.getCurrY());
        invalidate();
    }
}

public void smoothScrollTo(int destX, int destY) {
    int scrollX = getScrollX();
    int delta = destX - scrollX;
    // startScroll() 只是纪录滚动需要的数值
    mScroller.startScroll(scrollX, 0, delta, 0, 2000);
    // invalidate 触发 onDraw()，在 onDraw() 中会调用 computeScroll()
    invalidate();
}
```

`startScroll(int startX, int startY, int dx, int dy)`

`startScroll(int startX, int startY, int dx, int dy, int duration)`

 这两个方法并没有产生实际的 scroll，只是对 scroll 的参数做了记录。



#### GestureDetector

使用步骤：

* 在 view 中创建实例
* 在 View#onTouchEvent 方法里调用 GestureDetector#onTouchEvent 