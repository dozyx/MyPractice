> 关于权限的实践还比较缺乏，下面内容可能存在不足

权限需要在清单文件中声明，Android 从 6.0 加入运行时权限：

+ [普通权限](https://developer.android.com/guide/topics/permissions/normal-permissions.html)：在安装时系统授予
+ 危险权限：需要应用在运行时向用户请求授予

> Android 6.0 之前，权限在安装时进行授予，一旦拒绝后，将无法获得

### 运行时权限

运行时权限的处理主要涉及几个方法：

+ `ContextCompat.checkSelfPermission` - 检查应用是否已获得某个权限


+ `ActivityCompat.shouldShowRequestPermissionRationale` - 判断是否需要向用户进行说明，该方法的返回结果包括以下三种情况：
  + 第一次请求权限时，如果用户拒绝了，再次请求时返回true
  + 多次请求权限（超过一次），用户如果选择了不再询问并拒绝，返回false
  + 设备的策略禁止当前应用获取这个权限的授权，返回false
+ `ActivityCompat.requestPermissions`
+ `Activity#onRequestPermissionsResult`：请求权限结果回调

请求时对单个权限进行请求，但用户允许后将获得整个权限组的权限，并且下次不再需要询问。

示例代码：

```java
// Here, thisActivity is the current activity
if (ContextCompat.checkSelfPermission(thisActivity,
                Manifest.permission.READ_CONTACTS)
        != PackageManager.PERMISSION_GRANTED) {

    // Should we show an explanation?
    if (ActivityCompat.shouldShowRequestPermissionRationale(thisActivity,
            Manifest.permission.READ_CONTACTS)) {

        // Show an expanation to the user *asynchronously* -- don't block
        // this thread waiting for the user's response! After the user
        // sees the explanation, try again to request the permission.

    } else {

        // No explanation needed, we can request the permission.

        ActivityCompat.requestPermissions(thisActivity,
                new String[]{Manifest.permission.READ_CONTACTS},
                MY_PERMISSIONS_REQUEST_READ_CONTACTS);

        // MY_PERMISSIONS_REQUEST_READ_CONTACTS is an
        // app-defined int constant. The callback method gets the
        // result of the request.
    }
}
```

```java
@Override
public void onRequestPermissionsResult(int requestCode,
        String permissions[], int[] grantResults) {
    switch (requestCode) {
        case MY_PERMISSIONS_REQUEST_READ_CONTACTS: {
            // If request is cancelled, the result arrays are empty.
            if (grantResults.length > 0
                && grantResults[0] == PackageManager.PERMISSION_GRANTED) {

                // permission was granted, yay! Do the
                // contacts-related task you need to do.

            } else {

                // permission denied, boo! Disable the
                // functionality that depends on this permission.
            }
            return;
        }

        // other 'case' lines to check for other
        // permissions this app might request
    }
}
```



### PermissionsDispatcher 开源库

[github地址](http://www.10tiao.com/html/227/201610/2650237473/1.html)

使用该库可以通过注解简化权限处理流程。

#### 使用

+ 注解
  + @RuntimePermissions（必需）：注解Activity或Fragment
  + @NeedsPermission（必需）：注解需要使用特定权限的方法
  + @OnShowRationale：向用户说明请求权限的目的
  + @OnPermissionDenied
  + @OnNeverAskAgain：用户选择了不再询问
+ 委托
  + 在 onCreate 中调用MainActivityPermissionsDispatcher 的 showCameraWithPermissionCheck 和 onRequestPermissionsResult 方法。（MainActivity 对应使用运行时权限的 Activity，showCamera 为@NeedsPermission 注解的方法）

### 实践

+ app 的 targetSdkVersion <= 22，但运行在 23 以上的设备时，调用 checkSelfPermission 方法：
  + ContextCompat：将一直返回GRANTED（即使在设置中禁用了该权限）
  + PermissionChecker：返回 GRANTED 或者 PERMISSION_DENIED_APP_OP PERMISSION_DENIED_APP_OP 表示权限拒绝，因为 app 的操作没有得到允许，个人理解 app op 表示的是能否执行需要该权限的 IPC 操作。









参考：    

[Requesting Permissions](https://developer.android.com/guide/topics/permissions/requesting.html)

[Android 6.0运行时权限详解](http://www.10tiao.com/html/227/201610/2650237473/1.html)

[android各大手机系统打开权限管理页面](http://blog.csdn.net/vinomvp/article/details/52228377)

[PermissionChecker](https://developer.android.com/reference/android/support/v4/content/PermissionChecker.html)
[checkSelfPermission method is not working in targetSdkVersion 22](https://stackoverflow.com/questions/33407250/checkselfpermission-method-is-not-working-in-targetsdkversion-22)
[Should I prefer ContextCompat or PermissionChecker for permission checking on Android?](https://stackoverflow.com/questions/44813943/should-i-prefer-contextcompat-or-permissionchecker-for-permission-checking-on-an/44815034#44815034)