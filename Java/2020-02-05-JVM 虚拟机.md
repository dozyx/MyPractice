

### 运行时数据区域

线程共享：

* `方法区`

  **存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。**

  有些地方也将方法区称为「永久代」。这区域的内存回收目标主要是针对常量池的回收和对类型的卸载。

  * `运行时常量池`

    Class 文件中有一项信息是常量池，用于存放编译器生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。**运行期间也可以将新常量放入池中。**

* `堆`

  此内存区域的唯一目的就是存放对象实例。GC 管理的主要区域。

  从内存回收角度来看（现在的收集器基本都采用分代收集算法），细分为：**新生代**、**老年代**；更细致的有 Eden 空间、From Survivor空间、To Survivor 空间等。

  > 无论如何划分，都与存放内容无关，无论哪个区域，存储的都仍然是对象实例，进一步划分的目的是为了更好地回收内存，或者更快地分配内存。
  >

线程私有：

* `虚拟机栈`

  **Java 方法执行的内存模型**。每个方法在执行时都会创建一个**栈帧**用来存储局部变量表、操作数栈、动态链接、方法出口等信息。

  两种异常：StackOverflowError、OutOfMemoryError。

* `本地方法栈`

* `程序计数器`

  当前线程所执行的字节码的行号计数器。在执行 native 方法时，值为 Undefined。

  Java 虚拟机规范中唯一一个没有规定任何 OutOfMemoryError 情况的区域。



## 自动内存回收

哪些内存需要回收？

什么时候回收？

如何回收？

### 判断对象已死

* `引用计数法`

  主要问题：难以解决对象之间**相互循环引用问题**

* `可达性分析算法`

  `GC Roots` 对象包括

  * 虚拟机栈（栈帧中的本地变量表）中引用的对象
  * 方法区中类静态属性引用的对象
  * 方法区中常量引用的对象（static final）
  * 本地方法栈中JNI（即一般说的Native方法）引用的对象


#### finalize()

> 即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与GCRoots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。
>

如果在 finalize() 中将自己赋值给某个类变量或者对象的成员变量，将可以完成自我拯救。通过 finalize() 来实现自我拯救只有一次机会。



### 引用

由强到弱：

* 强引用
* 软引用：系统将要发生内存溢出异常之前回收，如果回收之后内存还是不够才抛出异常
* 弱引用：对象只能生存到下一次 gc 发生之前
* 虚引用：唯一目的是能在这个对象被回收时收到一个系统通知



### 垃圾收集算法

* `标记-清除算法`

  主要不足：效率问题；空间问题，产生内存碎片

* `复制算法`

  将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。

  不足：内存只使用了一半

  > 现在的商业虚拟机都采用这种收集算法来回收新生代，IBM公司的专门研究表明，新生代中的对象98%是“朝生夕死”的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块较大的 `Eden` 空间和两块较小的 `Survivor` 空间，每次使用 Eden 和其中一块 Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。

  > 疑问：每次使用 Eden 和其中一块 Survivor 理解？为什么需要两个 Survivor？
  >
  > 第一次 Minor GC 时，Eden 中存活的对象复制到其中一块 Survivor，再次发生 Minor GC 时，将 Eden 和 Survivor 中仍存活的对象复制到另一个到 Survivor。使用两个 Survivor 使 Survivor 里的对象也可以来回复制，减少内存碎片。
  >
  > https://www.zhihu.com/question/44929481
  >
  > https://blog.csdn.net/antony9118/article/details/51425581

* `标记-整理算法`

  > 复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。
  >
  > PS：50% 是指内存不按 1:1 划分，这样如果存活对象较多，另一块内存可能不够。

  根据老年代的特点，有人提出了另外一种“标记整理”（MarkCompact）算法，标记过程仍然与“标记清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是**让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存**。

* `分代收集算法`

  这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。

  一般将Java 堆分为新生代和老年代。**新生代**中选用**复制**算法，**老年代**使用**「标记-清除」或者「标记-整理」**算法。



### 内存分配与回收策略

* 对象优先在 Eden 分配

* 大对象直接进入老年代

* 长期存活的对象将进入老年代

  虚拟机给每个对象定义了一个对象年龄（Age）计数器。如果对象在Eden出生并经过第一次MinorGC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1。**对象在Survivor区中每“熬过”一次MinorGC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁），就将会被晋升到老年代中。**

* 动态对象年龄判断

  为了能更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。

* 空间分配担保

  在发生MinorGC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么MinorGC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次MinorGC，尽管这次MinorGC是有风险的；如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次FullGC。

  



资料：

《深入理解 Java虚拟机》

[【证】:那些可作为GC Roots的对象](https://blog.csdn.net/u010798968/article/details/72835255)