---
title: Object 的方法
tags:
  - java
date: 2017-09-19 12:13:09
categories: Java
---

> Object 是所有类的超类，几乎从第一天学习 Java 开始，我就已经知道 hashCode、equal、clone 等方法，但是突然让我讲讲它们，却感觉难以说清楚，仿佛只可意会不可言传。我希望通过这篇文章让自己实现言传的目的。



### clone

[Cloneable](https://docs.oracle.com/javase/7/docs/api/java/lang/Cloneable.html)

[Object.clone()](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#clone())

[Copy Constructor versus Cloning](http://www.artima.com/intv/bloch13.html)

在 Object 中的 clone() 方法实现如下：

```java
    protected Object clone() throws CloneNotSupportedException {
        if (!(this instanceof Cloneable)) {
            throw new CloneNotSupportedException("Class " + getClass().getName() +
                                                 " doesn't implement Cloneable");
        }

        return internalClone();
    }
```

它先判断该对象是否是 Cloneable 的一个实例，不是的话将抛出异常，是的话将调用 native 的internalClone() 方法进行 clone。所以，每个实现 clone 功能的类都要实现 Cloneable 接口。需要注意的是，Cloneable 只是一个指示 clone() 方法合法性的标记接口，它没有定义任何的 filed 和方法。

通常，实现了 Cloneable 接口的类同时也要重写 Object.clone() 方法，并将「protected」改为「public」，而且 clone() 返回的对象应该通过 super.clone() 来获得。

> 在 StackOverflow 的问题 「[About Java cloneable](https://stackoverflow.com/questions/4081858/about-java-cloneable)」中，第一个答案的第一句话是「The first thing you should know about `Cloneable` is - don't use it.」。。。瞬间懵了。。。在 《Effective Java》的第 10 条建议就是『谨慎地覆盖 clone』，作者推荐使用拷贝构造函数来替代『实现 Cloneable + 重写 clone』。结合 《Effective Java》内容和搜索结果，我总结一下自己理解的关于 Cloneable 的几条不足（不知道是不是因为《Effective Java》参考的 Java 版本太旧，感觉部分说明跟官方文档有出入，所以大致了解下就行）：
>
> + Cloneable 中没有 clone() 方法，这不是一种好的设计，比如使用者将该类型强制转化为 Cloneable 类型，将无法调用任何方法。
> + 没有良好的通用约定
> + 假如一个类对象的 filed 是一个可变对象，那么也需要对该 filed 进行 clone()，但如果该 filed 是 final 的将无法工作。
> + ​
>
> 所以，除了数组的 clone 外，其他地方都没必要使用 clone()，如果想要实现拷贝，建议创建一个拷贝构造函数。